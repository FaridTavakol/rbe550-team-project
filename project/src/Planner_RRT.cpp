/**
 * This module contains NeedleSteering, DFS, Djikstras, A* algorithms
 */

#include "Planner_RRT.hpp"
#include <numeric>
#include <functional>
#include <iostream>

namespace motion_planning
{
	Planner_RRT::Planner_RRT(double goal_bias,
							 double goal_region,
							 double nn_region,
							 int max_itr)			:	m_env(nullptr),
														m_start(),
														m_goal(),
														m_tree(),
														m_goal_bias(goal_bias),
														m_goal_region(goal_region),
														m_nn_region(nn_region),
														m_max_itr(max_itr)
	{

	}


	void Planner_RRT::init()
	{
		// [1] Initialize Random Generator
		// m_rd = std::random_device;												//Will be used to obtain a seed for the random number engine
	    m_gen = std::mt19937(m_rd());																//Standard mersenne_twister_engine seeded with rd()
	    m_distrib_x = std::uniform_int_distribution<>(0, m_env->m_grid->dimension(0)-1);	//Use `distrib` to transform the random unsigned int generated by gen into an int in [1, 6]
	    m_distrib_y = std::uniform_int_distribution<>(0, m_env->m_grid->dimension(1)-1);	// -1 cuz of 0 indexing of Eigen grid
	    m_distrib_z = std::uniform_int_distribution<>(0, m_env->m_grid->dimension(2)-1);	// -1 cuz of 0 indexing of Eigen grid
	    m_distrib = std::uniform_real_distribution<> (0, 1);
	}


	bool Planner_RRT::search(Environment* env,
							 const Eigen::Vector3i& start,  const Eigen::Vector3i& goal,
							 vector<list<Eigen::Vector3i>>& paths, int& steps)
	{
		bool found = false;
		steps = 0;
		paths.clear();

		// [0] Caching as dataMem for other member functions to use them
		m_env = env;
		m_start = make_shared<Node>(start(0), start(1), start(2));
		m_goal = make_shared<Node>(goal(0), goal(1), goal(2));
		init();

		cout << "searching . . ." << endl;

	    // [1] Initialize tree with start node
		m_tree.push_back(m_start);

		// Stop when goal reached or when max_itr reached even if goal not found yet
		int itr = 0;
		while ( dist(m_tree.back(), m_goal) > m_goal_region || itr <= m_max_itr )
		{
			++itr;

			// [2] Get a random new node
			auto rand_node = get_new_node();
			auto nn_node = get_nearest_node(rand_node);

			// [3] Extend the tree from nn_node and rand_node...until collision is detected
			if ( dist(nn_node, rand_node) <= m_nn_region )
			{
				check_collision(nn_node, rand_node);	// rand_node gets updated if collision is detected
				rand_node->parent = nn_node;
				m_tree.push_back(rand_node);
			}
		}

		// [4] if goal was reached, last node added would be close to goal
		if (dist(m_tree.back(), m_goal) <= m_goal_region)
		{
			found = true;
			m_goal->parent = m_tree.back();

			// [5] Update output path list
			generate_raw_path(paths);
			generate_smooth_path(paths);
			steps = paths.at(0).size();		// steps used in raw_path
		}
		else
		{
			found = false;
		}

		return found;
	}

	double Planner_RRT::dist(const shared_ptr<Node> n1,
							 const shared_ptr<Node> n2)
	{
		return sqrt( pow((n2->y - n1->y),2) + pow((n2->x - n1->x),2) + pow((n2->z - n1->z),2));
	}


	void Planner_RRT::generate_check_points_on_line(const Eigen::Vector3i& pt0,
												    const Eigen::Vector3i& pt1,
												    vector<Eigen::Vector3i>& check_points)
	{
		// [0]
		check_points.clear();
		if (pt0 == pt1)
		{
			check_points.push_back(pt0);
			return;
		}

		// [1] Creating vector of 3 points
		int x1 = pt0(0);
		int y1 = pt0(1);
		int z1 = pt0(2);

		int x2 = pt1(0);
		int y2 = pt1(1);
		int z2 = pt1(2);

		Eigen::Vector3d p0 = pt0.cast<double>();
		Eigen::Vector3d p1 = pt1.cast<double>();

		// [2] Linear Beizer function to draw curve (straight line) given 2 points
		auto L = [&](double t) -> Eigen::Vector3i
				 {
					// Formula
					Eigen::Vector3d p = (1-t)*p0 + t*p1;
					// Cast vec from double to int type.. >=0.5 would be ceil... floor otherwise
					Eigen::Vector3i _p;
					for (int i=0; i<p.size(); ++i)
					{
						_p(i) = ( p(i)-floor(p(i)) ) >= 0.5 ? ceil(p(i)) : floor(p(i));
					}
					return _p;
				 };

		// [3] Generating points along x spaced between some step_size
		int step_size = 1;

		int steps = 0;
		if (x2 > x1)			// walk rightward
		{
			steps = x2 -x1;
		}
		else if (x2 < x1)		// walk leftward
		{
			steps = x1 - x2;
		}
		else if (x1 == x2)		// when slope is inf
		{
			if (y2 > y1)		// walk upward
			{
				steps = y2 - y1;
			}
			else if (y2 < y1)	// walk downward
			{
				steps = y1 - y2;
			}
		}
		steps = steps * (1/step_size);	// increase num_of_steps based on step_size

		for (int i=0; i<=steps; ++i)
		{
			double t = (double)i/steps;
			check_points.push_back( L(t) );
		}

		return;
	}


	// To-Do: Update logic for reducing checks when multiple obs exists
	bool Planner_RRT::check_collision(const shared_ptr<Node> n1,
						 	 	 	  shared_ptr<Node> n2)
	{
		if (n1 == n2)
		{
			return false;
		}

		bool collision_exist = false;
		vector<Eigen::Vector3i> check_points;
		generate_check_points_on_line({n1->x, n1->y, n1->z}, {n2->x, n2->y, n2->z}, check_points);

		Eigen::Vector3i p_old = check_points.at(0);
		for (auto& p : check_points)
		{
			int x = p(0); 	int y = p(1);	int z = p(2);
			// Stop when 1st collision is detected and update n2 just before collision
			for (auto& obs : m_env->m_obstacles)
			{
				// if check_point is within the bounding box, then obstacle detected
				if (x >= obs->left && x <= obs->right &&
					y >= obs->top  && y <= obs->bottom &&
					z >= obs->front && z<= obs->back)

				{
					collision_exist = true;
					n2->x = p_old(0);
					n2->y = p_old(1);
					n2->z = p_old(2);
					break;
				}
			}
			p_old = p;

			if (collision_exist)	// then no need to check for rest of the check_points
				break;
		}

		return collision_exist;
	}


	shared_ptr<Node> Planner_RRT::get_new_node()
	{
		// Create the following in constructor cuz this fn will be called like a million times
	    /*
		std::random_device rd;	//Will be used to obtain a seed for the random number engine
	    std::mt19937 gen(rd());	//Standard mersenne_twister_engine seeded with rd()
	    std::uniform_int_distribution<> distrib_x(0, m_env->m_grid->cols());	//Use `distrib` to transform the random unsigned int generated by gen into an int in [1, 6]
	    std::uniform_int_distribution<> distrib_y(0, m_env->m_grid->rows());
	    std::uniform_real_distribution<> distrib(0, 1);
	    */

	    if (m_distrib(m_gen) <= m_goal_bias)
	    {
	    	int x = m_goal->x;
	    	int y = m_goal->y;
	    	int z = m_goal->z;
			return make_shared<Node>(x,y,z);
	    }
		else
		{
			int x = m_distrib_x(m_gen);
			int y = m_distrib_y(m_gen);
			int z = m_distrib_z(m_gen);
			return make_shared<Node>(x,y,z);
		}
	}


	// To-Do: Use kd-tree to optimize the search
	shared_ptr<Node> Planner_RRT::get_nearest_node(const shared_ptr<Node> rand_node)
	{
		shared_ptr<Node> nn = nullptr;	// nearest_node

		if (!m_tree.empty())		// m_tree will never be empty
		{
			nn = m_tree.at(0);
		}

		int min_dist = numeric_limits<int>::max();
		int tmp_dist = 0;

		for (auto& n : m_tree)
		{
			tmp_dist = dist(n, rand_node);
			if (tmp_dist < min_dist)
			{
				min_dist = tmp_dist;
				nn = n;
			}
		}

		return nn;
	}


	// To-Do: Use kd-tree to optimize the search
	void Planner_RRT::get_neighbors(const shared_ptr<Node> rand_node, vector<shared_ptr<Node>>& neighbors)
	{
		neighbors.clear();

		for (auto& n : m_tree)
		{
			int dis = dist(rand_node, n);
			if (dis <= m_nn_region)
			{
				neighbors.push_back(n);
			}
		}
	}


	void Planner_RRT::generate_raw_path(vector<list<Eigen::Vector3i>>& paths)
	{
		list<Eigen::Vector3i> path;

		auto n = m_goal;
		int x=0; int y=0; int z=0;
		while (n != m_start)
		{
			x = n->x;
			y = n->y;
			z = n->z;
			path.emplace_front(x,y,z);
			n = n->parent;
		}
		x = m_start->x;
		y = m_start->y;
		z = m_start->z;
		path.emplace_front(x,y,z);

		paths.push_back(path);
	}


	void Planner_RRT::generate_smooth_path(vector<list<Eigen::Vector3i>>& paths)
	{
		list<Eigen::Vector3i> path;
		const list<Eigen::Vector3i>& raw_path = paths.at(0);

		// [0] Find curve control points p0, p1, p2, p3
		Eigen::ArrayXf index = Eigen::ArrayXf::LinSpaced(4, 0, raw_path.size()-1);

		int x=0; int y=0; int z=0;
		x=m_start->x;	y=m_start->y;	z=m_start->z;			// 1st point - 0%
		Eigen::Vector3d p0(x,y,z);

		auto mid1 = raw_path.begin();
		std::advance(mid1, (int)index(1));		// 2nd point - 33%
		Eigen::Vector3d p1 = (*mid1).cast<double>();

		auto mid2 = raw_path.begin();
		std::advance(mid2, (int)index(2));		// 3rd point - 66%
		Eigen::Vector3d p2 = (*mid2).cast<double>();

		x=m_goal->x;	y=m_goal->y;	z=m_goal->z;			// 4th point - 100%
		Eigen::Vector3d p3(x,y,z);


		// [1] Cubic Beizer function given 4 points
		auto C = [&](double t) -> Eigen::Vector3i
				 {
					// Formula
					Eigen::Vector3d p = pow((1-t),3)*p0 + 3*pow((1-t),2)*t*p1 + 3*(1-t)*pow(t,2)*p2 + pow(t,3)*p3;

					// Cast vec from double to int type.. >=0.5 would be ceil... floor otherwise
					Eigen::Vector3i _p;
					for (int i=0; i<p.size(); ++i)
					{
						_p(i) = ( p(i)-floor(p(i)) ) >= 0.5 ? ceil(p(i)) : floor(p(i));
					}
					return _p;
				 };

		// [2] Using Beizer function
		int num_points_to_plot_smooth_curve = 11;
		Eigen::ArrayXf t = Eigen::ArrayXf::LinSpaced(num_points_to_plot_smooth_curve, 0, 1);

		path.clear();
		for (int i=0; i<t.size(); ++i)
		{
			path.push_back( C(t(i)) );
		}
		paths.push_back(path);
	}

}	// namespace motion_planning
